/*
 * Created on 21.05.2004
 */

/*
 * MekWars - Copyright (C) 2004 
 * 
 * Derived from MegaMekNET (http://www.sourceforge.net/projects/megameknet)
 * Original author Helge Richter (McWizard)
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 */

package client.campaign;

import java.util.StringTokenizer;
import java.util.TreeSet;

import client.MWClient;

import common.Army;
import common.Unit;

/**
 * Client-side representation of an Army. The CArmy has, when compared to
 * its server-side counterpart, very few functional methods, and mostly
 * serves as a holder for server data that the client needs in order to
 * represent forces graphically, load units into games, etc.
 */
public class CArmy extends Army {
	
	//VARS
	private MWClient mwclient;
	private TreeSet<String> legalOperations;
	private float rawForceSize = 0;
	
	//CONSTRUCTOR
	public CArmy() {
		super();
		legalOperations = new TreeSet<String>();
	}
	
	//METHODS
	/**
	 * Method that fills in Army data (common.Army value), given an
	 * informational String. Called from CPlayer.setArmyData() and
	 * CPlayer.setData(). In both instances, the string being passed
	 * is generated by the server and sent down using a PL| cmd.
	 */
	public void fromString(String s, CPlayer p, String delimiter, MWClient client){
		mwclient = client;
		StringTokenizer ST = new StringTokenizer(s, delimiter);
		setID(Integer.parseInt(ST.nextToken()));
		setBV(Integer.parseInt(ST.nextToken()));
		setLocked(Boolean.parseBoolean(ST.nextToken()));
		setName(ST.nextToken());
		setLowerLimiter(Integer.parseInt(ST.nextToken()));
		setUpperLimiter(Integer.parseInt(ST.nextToken()));
		int count = Integer.parseInt(ST.nextToken());
		for (int i = 0; i < count; i++) {
			CUnit u = p.getUnit(Integer.parseInt(ST.nextToken()));
			
			//do not add units with id 0 as their id has already been replaced --Torren
			if( u.getId() != 0)
			    addUnit(u);
		}
		if (ST.hasMoreElements()) {
			count = Integer.parseInt(ST.nextToken());
			for (int i = 0; i < count; i++) {
				int key = Integer.parseInt(ST.nextToken());
				int unit = Integer.parseInt(ST.nextToken());
				getC3Network().put(key,unit);
			}
		}
		
		if ( ST.hasMoreTokens() )
			this.setOpForceSize(Float.parseFloat(ST.nextToken()));
		
		if ( ST.hasMoreElements())
		{
			count = Integer.parseInt(ST.nextToken());
			for (int i = 0; i < count; i++) {
				int unit = Integer.parseInt(ST.nextToken());
				addCommander(unit);
			}
		}
		if (ST.hasMoreTokens())
		{
			boolean locked = Boolean.parseBoolean(ST.nextToken());
			if(locked)
				playerLockArmy();
			else
				playerUnlockArmy();
		} 
	}
	
	/**
	 * Method that adds a unit at the end of a CArmy.
	 */
	public void addUnit (CUnit u){
		getUnits().add(u);
	}
	
	/**
	 * Method that adds a unit to a CArmy, in a specified position.
	 * Called from CPlayer in response to a PL|RPU. See CPlayer.java
	 * and PL.java for more info.
	 */
	public void addUnit (CUnit u, int position){
		getUnits().add(position,u);
	}
	
	/**
	 * Method that returns an amriy's legal operations. Used
	 * throughout the client to build GUI elements.
	 */
	public TreeSet<String> getLegalOperations() {
		return legalOperations;
	}
	
	/**
	 * This method is used to port saved legal ops info to a newly added
	 * CArmy, if an army with the same ID previously existed. This allows
	 * the server to send updates (lost 1 type, etc) instead of resending
	 * all of an army's ops whenever data is resent to the client.
	 * 
	 * See CPlayer.setArmyData() for usage details.
	 */
	protected void setLegalOperations(TreeSet<String> ts) {
		legalOperations = ts;
	}
	
	/**
	 * Client-side duplication of SArmy's getOperationsBV math. If the client,
	 * via tha downloaded server config data, knows that Operation Flashpoint
	 * style BV adjustments are in use, the HQ calls this method in order to
	 * accurately display BV vs. 4 without forcing the server to recalculate
	 * BV every time a unit is added to/removed from an army.
	 * 
	 * See comments in SArmy for more information about how the adjustment is
	 * determined, etc.
	 */
/*	public int getOperationsBV() { 	 
		//if not using the operations rules, return a normal undamaged BV. 	 
		boolean useingOpRules = Boolean.parseBoolean(mwclient.getserverConfigs("UseOperationsRule")); 	 
		if (!useingOpRules) 	 
			return this.getBV(); 	 
		
		double thisRawSize = this.getRawForceSize();//use getter in case it's 0 	 
		//get the base force size. should be 4 for IS and 5 for Clans. 	 
		double opForceRawSize = Double.parseDouble(mwclient.getserverConfigs("BaseForceSize")); 
		
		if (opForceRawSize >= thisRawSize) 	 
			return this.getBV();//this force is smaller. no modification. 	 
		
		//else - calcualte an op BV. 	 
		//load the base force multiplier from config ... 	 
		double baseForcePenalty = Double.parseDouble(mwclient.getserverConfigs("BaseForcePenalty"));	 
		
		//calculate the force size different 	 
		double forceDifference = thisRawSize - opForceRawSize; 	 
		
		//determine the multipliers (penalty sizes) 	 
		double baseForceMultiplier = forceDifference * baseForcePenalty; 	 
		double rawForceMultiplier = forceDifference/opForceRawSize; 	 
		
		//determine which multiplier is lower, and make it the final multiplier 	 
		double finalMultiplier = 0; 	 
		if (baseForceMultiplier < rawForceMultiplier) 	 
			finalMultiplier = baseForceMultiplier; 	 
		else 	 
			finalMultiplier = rawForceMultiplier; 	 
		
		finalMultiplier += 1;//make a proper multipler. eg - 1.08 to increase BV by 8%
		return (int)(this.getBV()*finalMultiplier); 	 
		
	}//end getOperationsBV 	 
*/	
	
	/** 	 
	 * @return returns the raw force size (Force Mod Rule) 	 
	 */ 	 
	public float getRawForceSize() { 	 
		
		//dont recalculate if it isnt necessary 	 
		if (rawForceSize != 0)
			return rawForceSize;
		
		//no break, generate a raw force size 	 
		for (Unit u : this.getUnits()) { 	 
			if (u.getType() == Unit.INFANTRY) 	 
				rawForceSize += Float.parseFloat(mwclient.getserverConfigs("InfantryOperationsBVMod")); 	 
			else if (u.getType() == Unit.VEHICLE) 	 
				rawForceSize += Float.parseFloat(mwclient.getserverConfigs("VehicleOperationsBVMod"));
			else if ( u.getType() == Unit.BATTLEARMOR)
				rawForceSize += Float.parseFloat(mwclient.getserverConfigs("BAOperationsBVMod"));
			else if ( u.getType() == Unit.PROTOMEK)
				rawForceSize += Float.parseFloat(mwclient.getserverConfigs("ProtoOperationsBVMod"));
			else //all other allowed types have a 1.0 weight 	 
				rawForceSize += Float.parseFloat(mwclient.getserverConfigs("MekOperationsBVMod")); 	 
		}
		
		return rawForceSize; 	 
	}//end getRawForceSize() 	 

	/** 	 
	 * @param rfs - the forcesize to set (Operations Rule) 	 
	 */ 	 
	public void setRawForceSize(float rfs) { 	 
		rawForceSize = rfs; 	 
	} 	 

	public double forceSizeModifier(double opposingForceSize) {
		
/*		double myForceSize = 0;
		double mekSize = Double.parseDouble(mwclient.getserverConfigs("MekOperationsBVMod"));
		double veeSize = Double.parseDouble(mwclient.getserverConfigs("VehicleOperationsBVMod"));
		double baSize = Double.parseDouble(mwclient.getserverConfigs("BAOperationsBVMod"));
		double protoSize = Double.parseDouble(mwclient.getserverConfigs("ProtoOperationsBVMod"));
		double infSize = Double.parseDouble(mwclient.getserverConfigs("InfantryOperationsBVMod"));
		
		for ( Unit unit : this.getUnits() ){
			
			switch(unit.getType()){
			case Unit.MEK:
				myForceSize += mekSize;
				break;
			case Unit.VEHICLE:
				myForceSize += veeSize;
				break;
			case Unit.BATTLEARMOR: 
				myForceSize += baSize;
				break;
			case Unit.PROTOMEK:
				myForceSize += protoSize;
				break;
			case Unit.INFANTRY:
				myForceSize += infSize;
				break;
				default :
					myForceSize += 1;
				break;
			}
		}
		
		if ( myForceSize > opposingForceSize )
			return ((opposingForceSize/myForceSize)+(myForceSize/opposingForceSize))-1;
		return 1.0;*/
		
		double myForceSize = 0;
		
		this.setRawForceSize(0);
		myForceSize = this.getRawForceSize();
		
		if ( myForceSize > opposingForceSize )
			return ((opposingForceSize/myForceSize)+(myForceSize/opposingForceSize))-1;
		return 1.0;

	}
	
	public float getTotalTonnage(){
		
		float totalTonnage = 0;
		
		for (Unit unit: this.getUnits())
			totalTonnage += ((CUnit)unit).getEntity().getWeight();
		return totalTonnage;
	}

	public int getAverageWalk(){
		
		int walk = 0;
		
		if ( this.getUnits().size() < 1)
			return 0;
		
		for ( Unit unit : this.getUnits() ){
			CUnit en = (CUnit)unit;
			
			walk += en.getEntity().getWalkMP();
		}
		
		walk /= this.getUnits().size();
		
		return walk;
	}
	
	public int getAverageJump(){
		
		int walk = 0;
		
		if ( this.getUnits().size() < 1)
			return 0;
		
		for ( Unit unit : this.getUnits() ){
			CUnit en = (CUnit)unit;
			
			walk += en.getEntity().getJumpMP();
		}
		
		walk /= this.getUnits().size();
		
		return walk;
	}


}